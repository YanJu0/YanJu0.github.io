{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"SQL语句","slug":"SQL语句","date":"2022-03-18T01:14:54.089Z","updated":"2022-03-17T11:51:18.074Z","comments":true,"path":"2022/03/18/SQL语句/","link":"","permalink":"http://example.com/2022/03/18/SQL%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"SQL通用语法1.SQL语句可以当行书写或多行书写，以分号结尾2.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写3.注释： 单行注释：– 注释内容或 #注释内容（MySQL特有） 多行注释：&#x2F;* 注释*&#x2F; SQL分类1.DDL：操作数据库，表等2.DML：对表中的数据进行增删改操作3.DQL：对表中数据进行查询4.DCL：对数据库进行权限控制 DDL–操作数据库1.查询 SHOW DATABASES;2.创建 创建数据库CREATE DATABASE 数据库名称; 创建数据库（判断，如果不存在则创建） &gt;CREATE DATABASE IF NOT EXISTS 数据库名称； 3.删除 删除数据库 &gt;DROP DATABASE; 删除数据库（判断，如果存在则删除） &gt;DROP DATABASE IF EXISES 数据库名称; 4.使用数据库 查看当前使用的数据库 &gt;SELECT DATABASE(); 使用数据库 &gt;USE 数据库名称; DDL–操作表1.查询表 查询当前数据库下的所有表名称： &gt;SHOW TABLES; 查询表结构： &gt;DESC 表名称; 2.创建表 &gt;CREATE TABLE 表名（ 字段名1 数据类型1， 字段名2 数据类型2， …… 字段名n 数据类型n ); 注意：最后一行末尾，不能加逗号 MySQL支持多种数据类型，可分为三类： 3.删除表 删除表 &gt;DROP TABLE 表名; 删除表时判断表是否存在 &gt;DROP TABLE IF EXISTS 表名; 4.修改表 修改表名 &gt;ALTER TABLE 表名 RENAME TO 新表名; 添加一列 &gt;ALTER TABLE 表名 ADD 列名 数据类型; 修改数据类型 &gt;ALTER TABLE 表名 MODIFY 列名 数据类型; 修改列名和数据类型 &gt;ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型; 删除列 &gt;ALTER TABLE 表名 DROP 列名; DML1.添加 1.1 给指定的列添加数据 &gt;INSERT INTO 表名（列名1，列名2，…） VALUES(值1，值2，…); 1.2 给全部列添加数据 &gt;INSERT INTO 表名 VALUES(值1，值2...); 1.3 批量添加 &gt;INSERT INTO 表名（列名1，列名2，...）VALUES(值1，值2，...)，（值1，值2，...），（值1，值2，...）...; INSERT INTO 表名 VALUES（值1，值2，…），（值1，值2，…）…; 2.修改数据 &gt;UPDATE 表名 SET 列名1&#x3D;值1，列名2&#x3D;值2，…[WHERE 条件]; 注意：修改语句中如果不加条件，则将所有数据都修改！ 3.删除数据 DELETE FROM 表名 [WHERE 条件]; DQL1.查询语法1234567891011121314SELECT 字段列表FROM 表名列表WHERE 条件列表GROUP BY 分组列表HAVING 分组后条件ORDER BY 排序字段LIMIT 分页限定 2.基础查询2.1 查询多个字段 &gt;SELECT 字段列表 FROM表名; 查询所有列的数据，列名列表可以使用*来代替，不要使用！！ 2.2 去除重复记录 &gt;SELECT DISTINCT 字段列表 FROM 表名; 2.3 起别名 &gt;AS: AS也可以省略‘ eg:SELECT math AS 数学成绩 FROM stu; 3.条件查询(WHERE) 3.1条件查询语法 SELECT 字段列表 FROM 表名 WHERE 条件列表; 3.2条件 —-查询年龄在20-30岁的信息SELECT * FROM stu WHERE age&gt;&#x3D;20 &amp;&amp; age&lt;&#x3D;30;SELECT * FROM stu WHERE age&gt;&#x3D;20 AND age&lt;&#x3D;30;SELECT * FROM stu WHERE age BETWEEN 20 AND 30; —-查询生日在2001-1-1至2003-1-1之间的信息SELECT * FROM stu WHERE birthday&gt;&#x3D;2001-1-1 &amp;&amp; birthday&lt;&#x3D;2003-1-1;SELECT * FROM stu WHERE birthday&gt;&#x3D;2001-1-1 AND birthday&lt;&#x3D;2003-1-1;SELECT * FROM stu WHERE birthday BETWEEN 2001-1-1 AND 2003-1-1; 模糊查询 _单个字符 %多个字符查询姓“马”的信息SELECT * FROM stu WHERE name LIKE ‘马%’;查询姓名第二个字为“花”的信息SELECT * FROM stu WHERE name LIKE ‘_花%’;查询姓名中有“德”的信息SELECT * FROM stu WHERE name LIKE ‘%德%’; 4. 排序查询（ORDER BY）4.1排序查询语法 &gt;SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1]，排序字段名2 [排序方式2]...; 4.2排序方式 &gt; ASD:升序排列 DESC:降序排列 &gt; 注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序 5. 聚合函数5.1概念将一列数据作为一个整体，进行纵向计算 5.2聚合函数分类 函数名 功能 补充 count(列名) 统计数量（一般选用不为null的列） 取值：1.主键 2. * max(列名) 最大值 min(l列名) 最小值 当值为ull时不参与 sum(列名) 求和 avg(列名) 平均值 5.3聚合函数语法 SELECT 聚合函数名（列名） FROM 表; null值不参与所有的聚合运算 6. 分组查询(GROUP BY) SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义WHERE和HAVING的区别： 执行时机不一样：where是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤 可判断的条件不一样；where不能对聚合函数进行判断，having可以 7. 分页查询（LIMIT） SELECT 字段列表 FROM 表名 LIMIT 起始索引，查询条目数；起始索引：从零开始计算公式：起始索引&#x3D;（当前页码-1） * 每页显示的条目数","categories":[],"tags":[]},{"title":"java开发 日志框架","slug":"java开发 日志框架","date":"2022-03-18T01:14:54.084Z","updated":"2022-03-16T16:10:03.543Z","comments":true,"path":"2022/03/18/java开发 日志框架/","link":"","permalink":"http://example.com/2022/03/18/java%E5%BC%80%E5%8F%91%20%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/","excerpt":"","text":"一. 日志技术的概述程序中的日志可以用来记录程序运行过程中的信息，并可以进行永久的存储。 采用输出语句到控制台的弊端： 1.信息只能显示在控制台 2.不能将其记录到其他位置（文件，数据库） 3.想取消记录的信息需要修改代码才可以完成 日志技术具备的优势： 1.可以将系统执行的信息选择性的记录到指定的位置（控制台，文件，数据库）2.可以随时以开关的形式控制是否记录日志，无需修改代码 二. 日志技术体系日志规范：一些接口，提供给日志的实现框架设计的标准。 日志框架：牛人或第三方公司已经做好的日志记录实现代码，后来者可以直接拿去使用。 日志规范接口 Commons Logging(JCL)Simple Logging Facade for Java（slf4j） 日志实现对象 Log4JUL(java.uil.logging)Logback其他实现 三. Logback日志框架logback是基于slf4j的日志规范实现的框架。 Logback 的架构非常通用，可以在不同的情况下应用。目前，logback 分为三个模块，logback-core、logback-classic 和 logback-access。 logback-core 模块为其他两个模块奠定了基础。logback-classic 模块可以同化为 log4j 1.x 的显着改进版本。此外，logback-classic 原生实现了SLF4J API，因此您可以轻松地在 logback 和其他日志框架（例如 log4j 1.x 或 java.util.logging (JUL)）之间来回切换。 logback-access 模块与 Tomcat 和 Jetty 等 Servlet 容器集成，以提供 HTTP 访问日志功能。请注意，您可以轻松地在 logback-core 之上构建自己的模块。LOGBack官网logback-core，logback-classic，SLF4J API的jar包提取码：jjc3 四. Logback快速入门需求：导入logback日志技术到项目中，用于记录系统的日志信息。分析：1.在项目下新建文件夹lib，导入logback的相关jar包到该文件夹，并添加到项目依赖库中去。1.1创建一个新的模块1.2在模块中创建一个新的文件夹，名称为lib1.3把jar包直接拷贝进去1.4 将jar包添加到项目依赖库中去选中Jar包右键，点击add as library确定出现小箭头即可2.将logback的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）logback.xml 提取码：e6f23.在代码中获取日志对象 1public static final Logger LOGGER = LoggerFactory.getLogger(&quot;类对象&quot;); 新建一个Test的测试类 123456789101112131415161718192021222324252627import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class Test &#123; //创建Logback的日志对象，代表了日志技术。 //静态常量对象 public static final Logger LOGGER = LoggerFactory.getLogger(&quot;Test.class&quot;); public static void main(String[] args) &#123; //快捷键ctrl+alt+T try &#123; LOGGER.debug(&quot;Mian函数开始执行了&quot;); LOGGER.info(&quot;我要开始记录第二行日志，开始做除法&quot;); int a = 4; int b =0; int num = a/b; LOGGER.trace(&quot;a=&quot;+a); LOGGER.trace(&quot;b=&quot;+b); System.out.println(&quot;num=&quot;+num); &#125; catch (Exception e) &#123; e.printStackTrace(); LOGGER.error(&quot;出现问题&quot;+e); &#125; &#125;&#125; 注意：日志文件输出的地址由logback.xml文件决定，可自行更改4.使用日志对象LOGGER调用其方法输出不能的日志信息 五. Logback 配置详解5.1输出位置，格式设置Logback日志系统的特性都是通过核心配置文件Logback.xml控制的。 通过logback.xml中的标签可以设置输出位置和日志信息的详细格式。通常可以设置两个日志输出位置：控制台，系统文件 输出到控制台的配置标志 12&lt;!-- CONSOLE ：表示当前的日志信息是可以输出到控制台的。 --&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; 输出到系统文件的配置标志 12&lt;!-- File是输出的方向通向文件的 --&gt; &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; 输出日志的格式 12&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度，%msg：日志消息，%n是换行符--&gt;&lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; 1234567&lt;!-- 打印所有日志如果不包含console则控制台只打印错误日志--&gt; &lt;root level=&quot;ALL&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt; &lt;/root&gt; 5.2 对日志不同内容是否输出的控制 可以通过设置日志的出输出级别来控制哪些日志信息输出或不输出 日志级别：TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR；默认级别是debug（忽略大小写），对应其方法作用：用于控制系统中哪些日志级别是可以输出的，只输出级别不低于设定级别的日志信息。ALL和OF分别是打开全部日志信息及关闭全部日志信息。具体在 1234&gt;&lt;root level=&quot;Error&quot;/&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;&gt; &lt;appender-ref ref = &quot;FILE&quot;/&gt;&gt;&lt;/root&gt;","categories":[],"tags":[]},{"title":"java基础 IO流","slug":"java基础 IO流","date":"2022-03-18T01:14:54.076Z","updated":"2022-03-16T16:09:28.532Z","comments":true,"path":"2022/03/18/java基础 IO流/","link":"","permalink":"http://example.com/2022/03/18/java%E5%9F%BA%E7%A1%80%20IO%E6%B5%81/","excerpt":"","text":"缓冲流缓冲流概述缓冲流也称为高效流，或者高级流。之前学习的字节流可以成为原始流。见该文章: Java基础 file､方法递、IO流作用：缓冲流自带缓冲区，可以提高原始字节流，字符流写数据的性能。 BufferedInputSream 字节缓冲输入流BufferedOutputSream 字节缓冲输出流BufferedReader 字符缓冲输入流BufferedWriter 字符缓冲输出流 字节缓冲流字节缓冲输入流自带了8KB缓冲池，以后我们直接从缓冲池读取数据，所以性能比较好。字节流缓冲流自带了8KB缓冲池，数据就直接写入到缓冲池中去，写数据性能极高了。 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.*;import java.nio.charset.StandardCharsets;/** * 使用字节缓冲流完成数据的读写操作 */public class ByteBufferDemo &#123; public static void main(String[] args) &#123; try ( //这儿里面只能放置资源对象，用完会自动关闭 //自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作） // OutputStream os = new FileOutputStream(&quot;logback-APP\\\\\\\\src\\\\\\\\data&quot;);//先清空之前的数据，写新的数据 //1. 创建一个文件字节输出流管道与目标文件接通 OutputStream os = new FileOutputStream(&quot;IO\\\\data&quot;,true); //a.把原始的字节输入流包装成高级的缓冲字节输入流 OutputStream bos = new BufferedOutputStream(os); //2.创建一个字节·输入流管道与目标文件接通 //b.把字节输入流管道包装成高级的缓冲字节书入流管道 InputStream is = new FileInputStream(&quot;IO\\\\data01&quot;); InputStream bis = new BufferedInputStream(is); )&#123; //3.定义一个字节数组用于转移数据 byte [] buffer = new byte[1024]; int len;//记录每次读取的字节数 while ((len = bis.read(buffer))!=-1)&#123; bos.write(buffer,0,len); &#125; System.out.printf(&quot;复制完成&quot;); os.flush(); //写数据一定要刷新数据 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 字节缓冲流的性能分析用于直观感受字节缓冲流的性能需求：分别使用低级字节流和高级字节缓冲流拷贝大视频，记录耗时分析：1.使用低级的字节流按照一个一个字节的形式复制文件2.使用低级的字节流一个一个字节数组的形式复制文件3.使用高级的缓冲字节流按照一个一个字节的形式复制文件4.使用高级的缓冲字节流按照一个一个字节数组的形式复制文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import java.io.*;public class ByteBufferTimeDemo &#123; private static final String SRC_FILE = &quot;D:\\\\Microsoft Edge Download\\\\ideaIU-2021.3.2.exe&quot;;//文件所在地址 private static final String DEST_FILE = &quot;D:\\\\Microsoft Edge Download\\\\&quot;;//文件要复制到的地方+后面需要拼接该文件复制到该路径后的名称 public static void main(String[] args) &#123;// 1. 使用低级的字节流按照一个一个字节的形式复制文件:慢的让人无法忍受 //copy01();// 2. 使用低级的字节流一个一个字节数组的形式复制文件:比较慢 copy02();// 3. 使用高级的缓冲字节流按照一个一个字节的形式复制文件：很慢，不建议使用 copy03();// 4. 使用高级的缓冲字节流按照一个一个字节数组的形式复制文件：很快 copy04(); &#125; private static void copy04() &#123; long startTime = System.currentTimeMillis(); try ( //1. 创建一个文件字节输出流管道与目标文件接通 OutputStream os = new FileOutputStream(DEST_FILE+&quot;video4.exe&quot;); //a.把原始的字节输入流包装成高级的缓冲字节输入流 OutputStream bos = new BufferedOutputStream(os); //2.创建一个字节·输入流管道与目标文件接通 //b.把字节输入流管道包装成高级的缓冲字节书入流管道 InputStream is = new FileInputStream(SRC_FILE); InputStream bis = new BufferedInputStream(is); )&#123; //3.定义一个字节数组用于转移数据 byte [] buffer = new byte[1024]; int len;//记录每次读取的字节数 while ((len = bis.read(buffer))!=-1)&#123; bos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; long endTime = System.currentTimeMillis(); System.out.println(&quot;使用高级的缓冲字节流按照一个一个字节数组的形式复制文件耗时:&quot;+(endTime-startTime)/1000.0+&quot;秒&quot;); &#125; private static void copy03() &#123; long startTime = System.currentTimeMillis(); try ( //1. 创建一个文件字节输出流管道与目标文件接通 OutputStream os = new FileOutputStream(DEST_FILE+&quot;video3.exe&quot;); //a.把原始的字节输入流包装成高级的缓冲字节输入流 OutputStream bos = new BufferedOutputStream(os); //2.创建一个字节·输入流管道与目标文件接通 //b.把字节输入流管道包装成高级的缓冲字节书入流管道 InputStream is = new FileInputStream(SRC_FILE); InputStream bis = new BufferedInputStream(is); )&#123; //3.定义一个变量用于转移数据 int b;//记录每次读取的字节数 while ((b = bis.read())!=-1)&#123; bos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; long endTime = System.currentTimeMillis(); System.out.println(&quot;使用高级的缓冲字节流按照一个一个字节的形式复制文件耗时:&quot;+(endTime-startTime)/1000.0+&quot;秒&quot;); &#125; // //a.把原始的字节输入流包装成高级的缓冲字节输入流 // OutputStream bos = new BufferedOutputStream(os); //b.把字节输入流管道包装成高级的缓冲字节书入流管道 // InputStream bis = new BufferedInputStream(is); private static void copy02() &#123; long startTime = System.currentTimeMillis(); try ( //1. 创建一个文件字节输出流管道与目标文件接通 OutputStream os = new FileOutputStream(DEST_FILE+&quot;video2.exe&quot;); //2.创建一个字节·输入流管道与目标文件接通 InputStream is = new FileInputStream(SRC_FILE); )&#123; //3.定义一个字节数组用于转移数据 byte [] buffer = new byte[1024]; int len;//记录每次读取的字节数 while ((len = is.read(buffer))!=-1)&#123; os.write(buffer,0,len); &#125; System.out.printf(&quot;复制完成&quot;); os.flush(); //写数据一定要刷新数据 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; long endTime = System.currentTimeMillis(); System.out.println(&quot;使用低级的字节流按照一个一个字节数组的形式复制文件耗时:&quot;+(endTime-startTime)/1000.0+&quot;秒&quot;); &#125; /** * 使用低级的字节流按照一个一个字节的形式复制文件 */ private static void copy01() &#123; long startTime = System.currentTimeMillis(); try ( //1.创建低级的字节输入流和源文件链接 InputStream is = new FileInputStream(SRC_FILE); //2.创建低级的字节输出流和源文件链接 OutputStream os = new FileOutputStream(DEST_FILE+&quot;video1.exe&quot;); )&#123; //3.定义一个变量记录每次读取的字节（一个一个字节的复制） int b; while ((b = is.read())!=-1)&#123; os.write(b); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; long endTime = System.currentTimeMillis(); System.out.println(&quot;使用低级的字节流按照一个一个字节的形式复制文件耗时:&quot;+(endTime-startTime)/1000.0+&quot;秒&quot;); &#125;&#125; 把低级字节流数组的小更改为原来的八倍（高级缓冲字节流自带8KB的缓冲区）缓冲流采用1KB的字节数组即可 字符缓冲流字节缓冲输入流：BufferedReader作用:提高字符输入流读取的性能，除此之外多了按照行读取数据的功能 public ReadLine() 123456789101112131415161718192021222324252627282930313233import java.io.BufferedReader;import java.io.FileReader;import java.io.Reader;public class BufferedReaderDemo &#123; public static void main(String[] args) &#123; try( //1.创建个文件字符输出流与文件接通 Reader fr = new FileReader(&quot;IO\\\\data&quot;); //q.把低级的字符流包装成高级的缓冲流 BufferedReader br = new BufferedReader(fr); ) &#123;// //2.用循环读取一个字符数组的数据// int len;// char[] buffer = new char[1024];// while((len = br.read(buffer))!=-1)&#123;// System.out.printf(new String(buffer,0,len));// &#125; // System.out.printf( br.readLine()); //经典写法：行读很重要 String Line; while ((Line=br.readLine())!=null)&#123; System.out.println(Line); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 字节缓冲输出流：BufferedWriter作用:提高字符输出流读取的性能，除此之外多了换行功能 转换流当代码编码于文件编码不一致时，使用字符流直接读取中文会乱码。字符流直接读取文本内容，必须文件和代码编码一直才不会出现乱码 字符输入转换流（InputStreamReader）字符输入转换流：把原始字节流按照指定的编码转换成字符输入流 1234567891011121314151617181920import java.io.*;public class inputStreamReaderDemo &#123; public static void main(String[] args)throws Exception &#123; //代码UTF-8 文件GBK //1.提取GBK文件的原始字节流 InputStream is = new FileInputStream(&quot;&quot;); //2.把原始字节流转换为字符输入流 //Reader isr = new InputStreamReader(is);//默认以UTF-8的方式转换为字符流，还是会乱码的 跟直接使用FileReader一致 Reader isr = new InputStreamReader(is,&quot;GBK&quot;);//以指定的GBK编码转换为字符输入流 BufferedReader br = new BufferedReader(isr);//缓冲流 String line ; while ((line=br.readLine())!=null)&#123; System.out.println(line); &#125; &#125;&#125; 字符输出转换流(OutputStreamWriter) 12345678910111213141516171819202122import java.io.*;//目标：使用OutputStreamWriterpublic class OutputStreamWriterDemo &#123; public static void main(String[] args) throws Exception &#123; //1.定义一个字节输出流 OutputStream os = new FileOutputStream(&quot;&quot;); //2.把原始字节输出流转换为字符输出流 //Writer osw = new OutputStreamWriter(os);//一默认的方式UTF-8 跟直接写FileRead一样 Writer osw = new OutputStreamWriter(os,&quot;GBK&quot;);//指定GBK的方式写字符出去 //3.把低级的字符输出流包装成高级的缓冲字符流 BufferedWriter bw = new BufferedWriter(osw); bw.write(&quot;我爱中国&quot;); bw.close(); &#125;&#125; 序列化对象对象序列化作用：以内存为基准，把内存中的对象存储到磁盘中去，称为对象序列化对象字节输出流：ObjectOutputStream,写对象数据到数据磁盘中规定：如果你想将该对象序列化，那么该对象一定要实现Serializable接口存储结果，并非乱码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.io.Serializable;public class Student &#123; private String name; private int age; private String loginName; private String passWord; public Student() &#123; &#125; public Student(String name, int age, String loginName, String passWord) &#123; this.name = name; this.age = age; this.loginName = loginName; this.passWord = passWord; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getLoginName() &#123; return loginName; &#125; public void setLoginName(String loginName) &#123; this.loginName = loginName; &#125; public String getPassWord() &#123; return passWord; &#125; public void setPassWord(String passWord) &#123; this.passWord = passWord; &#125; @Override public String toString() &#123; return &quot;student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, loginName=&#x27;&quot; + loginName + &#x27;\\&#x27;&#x27; + &quot;, passWord=&#x27;&quot; + passWord + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 1234567891011121314151617181920212223import java.io.FileOutputStream;import java.io.ObjectOutputStream;public class ObjectOutputStreamDemo &#123; public static void main(String[] args) throws Exception &#123; //1.创建一个对象 Student s = new Student(&quot;晓星尘&quot;,23,&quot;xiaoxingchen&quot;,&quot;123456&quot;); //2.把对象存储 //对象序列化：使用对象字节输出流包装字节输出流管道 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;IO\\\\data&quot;)); //3.直接调用序列化方法 oos.writeObject(s); //4.释放资源 oos.close(); //规定： //如果你想将该对象序列化，那么该对象一定要实现Serializable接口 &#125;&#125; 对象反序列化作用:以内存为基准，把存储到磁盘文件中的对象数据恢复成内存中的对象对象字节输入流：ObjectInputStream 注意：transient 注意： serialVersionUIDprivate static final long serialVersionUID：序列化版本号 如果之前序列化版本号serialVersionUID的值为1，对该类的对象进行序列化，在对其序列化得到的文件进行反序列化，可以成功获取该对象将该序列化版本号serialVersionUID的值改为2，未对其再次进行序列化（之前文件的序列化版本号为1），反序列化（此时反序列化的版本号为2）之前的文件将会出现错误。序列化的版本号于反序列化的版本号需一致需对该对象再次进行序列化即可 打印流作用：打印流可以实现方便，高效的打印数据到文件中去。可以实现打印什么数据就是什么数据 PrintStream 12345678910111213141516171819import java.io.PrintStream;//打印流写数据高效且方便//底层实现使用了BufferWriterpublic class printDemo &#123; public static void main(String[] args) throws Exception&#123; //1.创建一个打印流对象 //PrintStream ps = new PrintStream(new FileOutputStream(&quot;&quot;)); //可以通向低级管道 PrintStream ps = new PrintStream(&quot;IO/data&quot;,&quot;GBK&quot;);//可以直接通向文件 ，可以确定编码 ps.println(97); ps.println(&#x27;a&#x27;); ps.println(&quot;写啥打印啥&quot;); ps.flush(); ps.close(); &#125;&#125; PrintWriter 123456789101112131415161718192021import java.io.PrintWriter;//打印流写数据高效且方便//底层实现使用了BufferWriter//打印上PrintStream与PrintWriter没有区别public class printDemo &#123; public static void main(String[] args) throws Exception&#123; //1.创建一个打印流对象 //PrintWriter ps = new PrintWriter(new FileOutputStream(&quot;&quot;)); //可以通向低级管道 PrintWriter ps = new PrintWriter(&quot;IO/data&quot;,&quot;GBK&quot;);//可以直接通向文件 ，可以确定编码 ps.println(97); ps.println(&#x27;a&#x27;); ps.println(&quot;写啥打印啥&quot;); ps.flush(); ps.close(); &#125;&#125; PrintStream与PrintWriter的区别 打印数据功能上是一摸一样的，都是使用方便，性能高效printStream继承自字节输出流OutputStream，支持写字节数据的方法PrintWriter继承自字符输出流Writer，支持字符数据的方法 补充知识：PropertiesPropeties其实是一个Map集合，一般不会当集合用，核心作用是将Properties代表一个属性文件，可以把对象中的键值对信息存入到一个属性文件中去。属性文件：后缀是.properties结尾的文件，里面的内容都是key&#x3D;value,后续做系统配置文件的。properties和IO流结合的方法 123456789101112131415161718192021222324252627282930import java.io.FileReader;import java.io.FileWriter;import java.util.Properties;public class PropertiesDemo &#123; public static void main(String[] args) throws Exception&#123; //需求：使用Properties把键值对存入到属性文件中 Properties properties_writer = new Properties(); properties_writer.setProperty(&quot;d&quot;,&quot;12434&quot;); properties_writer.setProperty(&quot;jadk&quot;,&quot;jsdlks&quot;); /** * 参数一：保存管道 * 参数二：保存心得 */ properties_writer.store(new FileWriter(&quot;IO\\\\data02.properties&quot;),&quot;注释&quot;); //_____________________________________________ //需求：使用Properties把键值对从属性文件中读取出来 Properties properties_read = new Properties(); //加载 properties_read.load(new FileReader(&quot;IO\\\\data02.properties&quot;)); System.out.println(properties_read); &#125;&#125; 补充知识：IO框架commons-io概述commons-io工具包提供了很多关于io操作的类。有两个主要的类FileUtils,IOUtilscommons-io 下载 提取码：xs90 简单使用 导入commons-io-2.6.jar做开发需求：使用commins-io简化io流读写分析:1.在项目中创建一个文件夹lib2.将commons-io-2.6.jar文件复制到lib文件夹中3.在jar文件上点击右键，选择Add as Library -&gt; 点击OK4.在类中导包使用 &#96;&#96;&#96; import org.apache.commons.io.FileUtils;import org.apache.commons.io.IOUtils; import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream; public class CommonsIODemo { public static void main(String[] args) throws Exception{ &#x2F;&#x2F;1.完成文件的复制&#x2F;&#x2F; IOUtils.copy(new FileInputStream(“”),&#x2F;&#x2F; new FileOutputStream(“”)); //2.完成文件复制到某个文件夹下 &#x2F;&#x2F; FileUtils.copyFileToDirectory(new File(“”),&#x2F;&#x2F; new File(“”)); //3.完成文件夹复制到某个文件夹下 &#x2F;&#x2F; FileUtils.copyDirectoryToDirectory(new File(“”),&#x2F;&#x2F; new File(“”)); //删除文件夹 &#x2F;&#x2F; FileUtils.delete(new File(“”)); &#125; }","categories":[],"tags":[]},{"title":"Java基础 file､方法递、IO流","slug":"Java基础 file､方法递、IO流","date":"2022-03-18T01:14:54.070Z","updated":"2022-03-16T16:08:48.510Z","comments":true,"path":"2022/03/18/Java基础 file､方法递、IO流/","link":"","permalink":"http://example.com/2022/03/18/Java%E5%9F%BA%E7%A1%80%20file%EF%BD%A4%E6%96%B9%E6%B3%95%E9%80%92%E3%80%81IO%E6%B5%81/","excerpt":"","text":"File类概述File类在包 java.io.File下，代表操作系统的文件对象（文件、文件夹）File类提供了诸如：定位文件获取文件本身信息，删除文件，创建文件（文件夹）等功能 File类创建对象1234//构造方法File (String pathname ) File （File parent, String child）File（File parent String , String child） 创建File对象（指定文件的路径）路径写法：1.D:\\study\\xuesheng.jpeg2.D:&#x2F;study&#x2F;xuesheng.jpeg 创建File对象（支持绝对路经，支持相对路径（重点））绝对路经：从盘符开始，依赖当前系统相对路经：一般定位于模块中的文件的，定位到工程下 1File f = new File(“file-io-app.src.data.txt”); File 创建对象（可以是文件也可以是文件夹）file常用API判断文件类型，获取文件信息 123File f = new File (“D:\\\\study\\\\xuesheng.jpeg”);long time = f.lastModified();System.out.println(“最后的修改时间是”+new SimpleDateFormat(“yyyy/MM/did HH:mm:ss”).format(time)); 创建文件，删除文件功能删除文件，占用也可以删除 遍历文件夹 1234567891011121314151617//1. 定位一个目录File f = new File (&quot;D:/study&quot;);String [] names = f.list();for(String name:names)&#123; System.out.println(&quot;name&quot;);&#125;//2.只能遍历 一级文件对象File files = f.listFiles();for(File file:files)&#123; System.out.println(&quot;file.getAbsolutePath()&quot;);&#125;//3.listFiles 注意事项：//当调用者不存在时，返回null//当调用者是一个文件时，返回null//当调用着是一个空文件夹时，返回一个长度为0的数组//当调用者是一个有内容的文件夹时,将文件和文件夹的路径放在File数组中//当调用者是一个有隐藏文件的文件夹时，将里面所有的文件和文件夹的路径放在File数组中返回，包含隐藏内容 方法递归（文件搜索）递归的形式和特点方法递归：方法直接调用自己或者间接调用自己的形式称为方法递归 直接递归：方法自己调用自己间接递归：方法调用其他方法，其他方法又回调方法自己 递归的算法流程，核心要素 导学-计算1-n的阶乘公式为f(n) &#x3D; f(n-1)*n; 非规律化递归案例-文件搜索 需求：文件搜索，从C盘中，搜索出某个文件名称并输出绝对路径分析： 1.先定位出的应该是一级文件对象 2.遍历所有一级文件对象，判断是否为文件 3.如果是文件，判断是否为自己想要 4.如果是文件夹，需要继续递归进去重复上述过程 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.File;public class RecursionDemo &#123; public static void main(String[] args) &#123; //2. 传入目录 和 文件名称 File file = new File(&quot;D:/&quot;); searchFile(file,&quot;dhdgffkkebhmkfjojejmpbldmpobfkfo&quot;); &#125; /** *1. 搜索某个目录下的全部文件，找到我们想要的 * @param dir 被搜索的源目录 * @param fileName 被搜索的文件名称 */ public static void searchFile(File dir,String fileName)&#123; //3. 判断dir是否为目录 if(dir!=null &amp;&amp; dir.isDirectory())&#123; //可以找了 //4. 提取当前目录下的以及文件对象 File files[] = dir.listFiles(); //5. 判断是否存在一级文件对象，存在在遍历 if(files !=null&amp;&amp;files.length!=0)&#123; for (File file :files)&#123; //6. 判断当前的一级文件对象是文件还是目录 if(file.isFile())&#123; //7. 是不是我们要找的 if(file.getName().contains((fileName)))&#123; System.out.println(&quot;找到了&quot;+file.getAbsoluteFile()); &#125; //8. 是文件夹 &#125;else &#123; searchFile(file,fileName); &#125; &#125; &#125; &#125;else&#123; System.out.println(&quot;对不起当前搜索的位置不是文件夹&quot;); &#125; &#125;&#125; 字符集常见字符集介绍 基础知识 1.计算机底层不能直接存储字符的，计算机中底层只能存储二进制（0，1） 2.二进制是可以转换为十进制的 3.计算机底层是可以表示十进制编号。计算机可以给文类字符进行编号存储，这套编号规则就是字符集ASCII字符集GBKUnicode码表（统一码，万国码）：由于Unicode会先通过UTF-8的编码称二进制后再存储到计算机 字符串常见的字符组成：英文和数字等在任何国家的字符集中都占一个字节GBK字符中一个英文字符占2个字节UTF-8编码中一个中文一般占三个字节编码前的字符集和编码好的字符集必须一致，否则会出现中文符乱码 字符集的编码，解码操作 12345678910111213141516171819202122232425262728293031import java.io.UnsupportedEncodingException;import java.nio.charset.StandardCharsets;import java.util.Arrays;public class Test &#123; public static void main(String[] args) &#123; //1. 编码：把文字转换为字节（使用指定编码） String name = &quot;abc我爱你中国&quot;; byte[] bytes = new byte[0];//以当前代码默认字符集进行编码（UTF-8） // bytes = name.getBytes(); try &#123; bytes = name.getBytes(&quot;GBK&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; System.out.println(bytes.length); System.out.println(Arrays.toString(bytes)); //2. 解码：把字节转换成对应的中文形式（编码前和编码后的字符集必须一致，否则乱码） String rs = null;//默认UTF-8 try &#123; rs = new String(bytes,&quot;GBK&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; System.out.println(rs); &#125;&#125; IO流概述分类按流的方向分IO流也称为输入，输出流，就是用来读写数据的I表示input，是从数据从硬盘文件读入到内存的过程，称之输入，负责读O表示output，是内存程序的数据从内存写出到硬盘文件的过程，称之为输出，负责写按流中的数据最小单位分字节流字符流组合 流 概念 抽象类 字节输入流 以内存为基准，来自磁盘文件&#x2F;网络中的数据以字节的形式读入到内存中去的流 InputStream 字节输出流 以内存为基准，把来自内存中的数据以字节写出到磁盘文件&#x2F;网络中去的流 OutputStream 字符输入流 以内存为基准，来自磁盘文件&#x2F;网络中的数据以字符的形式读入到内存中去的流 Reader 字符输出流 以内存为基准，把来自内存中的数据以字符写出到磁盘文件&#x2F;网络中去的流 Writer 字节流的使用字节流适合做一切文件数据的拷贝，任何文件底层都是字节，拷贝是一字不漏地转移字节，只要前后的文件格式，编码一致没有任何问题。 字节输入流：每次读取一个字节输出结果 12345678910111213141516171819202122232425262728import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class FileInputSream &#123; public static void main(String[] args) &#123; try &#123; //1. 创建一个文件字节输出流管道与源文件接通 //InputStream is = new FileInputStream(new File(&quot;SuanFa\\\\logback-APP\\\\srd\\\\data&quot;)); //简写 InputStream is = new FileInputStream(&quot;logback-APP\\\\src\\\\data&quot;);// //读取一个字符并返回// int bi = is.read();// System.out.println((char) bi); int b ; while ((b = is.read())!=-1)&#123; System.out.print((char) b); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 每次读取一个字节存在的问题 性能比较慢 读取中文字符输出无法避免乱码问题 字节输入流：每次读取一个字节数组 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.FileInputStream;import java.io.InputStream;public class FileInputSream_Demo02 &#123; /** *目标：使用文件字节输入流每次读取一个字节数组的数据 */ public static void main(String[] args) throws Exception&#123; //1. 创建一个文件字节输入流管道与源文件接通 InputStream is = new FileInputStream(&quot;logback-APP\\\\src\\\\data&quot;);// //2. 定义一个字节数组，用于读取字节数组// byte[] buffer = new byte[3];// int len1 = is.read(buffer);// System.out.println(&quot;读取了几个字节&quot;+len1);// String rs1 = new String(buffer);// System.out.println(rs1);//// int len2 = is.read(buffer);// System.out.println(&quot;读取了几个字节&quot;+len2);// String rs2 = new String(buffer);// System.out.println(rs2);//// int len3 = is.read(buffer);// System.out.println(&quot;读取了几个字节&quot;+len3);// //读取多少，倒出多少// String rs3 = new String(buffer,0,len3);// System.out.println(rs3);// //使用循环 byte[] buffer = new byte[3]; int len ; while((len=is.read(buffer))!=-1)&#123; //读取多少，倒出多少 System.out.print(new String(buffer,0,len)); &#125; &#125;&#125; 每次读取一个字节数组存在的问题 性能得到了提升 读取中文字符输出无法避免乱码问题 字节输入流：一次读完全部字节 如何使用字节输入流读取中文内容输出不出现乱码 定义一个与文件一样大的字节数组，一次性读取完文件的全部字节直接把文件数据读取到一个字节数组可以避免乱码存在的问题、 如果文件过大，字节数组可能引起内存溢出 方式一：自己·定义一个与文件大小一样大，然后使用读取字节数组的方法，一次性读取完成 123456789101112131415161718192021222324import java.io.File;import java.io.FileInputStream;import java.io.InputStream;public class FileInputSream_Demo03 &#123; /** *目标：使用文件字节输入流一次读取文件中的所有数据，可以解决中文乱码问题 */ public static void main(String[] args) throws Exception&#123; //1. 创建一个文件字节输入流管道与源文件接通 File f = new File(&quot;logback-APP\\\\src\\\\data&quot;); InputStream is = new FileInputStream(f); //2.定义一个字节数组与文件的大小一样大 byte [] buffer = new byte[(int)f.length()]; int len = is.read(buffer); System.out.println(&quot;读取了多少字节&quot;+len); System.out.println(&quot;文件大小&quot;+f.length()); System.out.println(new String(buffer)); &#125;&#125; 方法二：官方为字节输入流InputStream提供了如下API可以将字节把文件全部数据提取到一个字节数组中 1bytes [] buffer = is.readAllBytes(); 字节输出流：写字节数据到文件 12345678910111213141516171819202122232425262728293031323334import java.io.FileOutputStream;import java.io.OutputStream;import java.nio.charset.StandardCharsets;public class FileOutputSream_Demo01 &#123; public static void main(String[] args) throws Exception&#123; //1. 创建一个文件字节输出流管道与目标文件接通 OutputStream os = new FileOutputStream(&quot;logback-APP\\\\\\\\src\\\\\\\\data&quot;,true); // OutputStream os = new FileOutputStream(&quot;logback-APP\\\\\\\\src\\\\\\\\data&quot;);//先清空之前的数据，写新的数据 //2. 写数据出去 //a. public void write(int a):写一个字节出去 os.write(&#x27;a&#x27;); os.write(98); // os.write(&#x27;徐&#x27;); os.write(&quot;\\r\\n&quot;.getBytes(StandardCharsets.UTF_8));//如果只有\\n在windows系统中会是换行符，但是在linux系统中将不能识别，\\r\\n在很多系统中均适用 //b. public void write(byte[] buffer):写一个字节数组出去 byte [] buffer = &#123;&#x27;a&#x27;,97,98,99&#125;; os.write(buffer); os.write(&quot;\\r\\n&quot;.getBytes(StandardCharsets.UTF_8)); byte [] buffer2 = &quot;我是中国人&quot;.getBytes(StandardCharsets.UTF_8); os.write(buffer2); os.write(&quot;\\r\\n&quot;.getBytes(StandardCharsets.UTF_8)); //c. public void write(byte[] buffer):写一个字节数组的一部分出去 byte [] buffer3 = &#123;&#x27;a&#x27;,97,98,99&#125;; os.write(buffer3,0,3); os.write(&quot;\\r\\n&quot;.getBytes(StandardCharsets.UTF_8)); os.flush(); //写数据一定要刷新数据 os.close();//释放资源，包含了刷新的！关闭后流不可以再用 &#125;&#125; 资源释放的方式try-catch-finallyfinally：在处理异常时提供finally块来执行所有清除操作特点：被finally控制的语句最终一定会执行，除非JVM退出（System.exit();）作用：finally代码块是最终一定要执行的，可以在代码执行完毕的最后用于释放资源 12345678//格式try&#123;&#125;catch(Exception e)&#123;&#125;finally&#123;&#125; 12345678910111213141516171819202122232425262728293031323334import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.nio.charset.StandardCharsets;public class FileOutputSream_Demo01 &#123; public static void main(String[] args) &#123; OutputStream os = null; try &#123; //1. 创建一个文件字节输出流管道与目标文件接通 os = new FileOutputStream(&quot;logback-APP\\\\\\\\src\\\\\\\\data&quot;,true); // OutputStream os = new FileOutputStream(&quot;logback-APP\\\\\\\\src\\\\\\\\data&quot;);//先清空之前的数据，写新的数据 //2. 写数据出去 //a. public void write(int a):写一个字节出去 os.write(&#x27;a&#x27;); os.write(98); // os.write(&#x27;徐&#x27;); os.write(&quot;\\r\\n&quot;.getBytes(StandardCharsets.UTF_8));//如果只有\\n在windows系统中会是换行符，但是在linux系统中将不能识别，\\r\\n在很多系统中均适用 os.flush(); //写数据一定要刷新数据 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(os!=null)os.close();//释放资源，包含了刷新的！关闭后流不可以再用 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; try-with-resource12345try(定义流对象)&#123; 可能出现异常的代码&#125;catch(异常类名 变量名)&#123; 异常处理代码&#125; 123456789101112131415161718192021222324252627282930313233import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.nio.charset.StandardCharsets;public class FileOutputSream_Demo01 &#123; public static void main(String[] args) &#123; try ( //这儿里面只能放置资源对象，用完会自动关闭 //自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作） //1. 创建一个文件字节输出流管道与目标文件接通 OutputStream os = new FileOutputStream(&quot;logback-APP\\\\\\\\src\\\\\\\\data&quot;,true); // OutputStream os = new FileOutputStream(&quot;logback-APP\\\\\\\\src\\\\\\\\data&quot;);//先清空之前的数据，写新的数据 )&#123; //2. 写数据出去 //a. public void write(int a):写一个字节出去 os.write(&#x27;a&#x27;); os.write(98); // os.write(&#x27;徐&#x27;); os.write(&quot;\\r\\n&quot;.getBytes(StandardCharsets.UTF_8));//如果只有\\n在windows系统中会是换行符，但是在linux系统中将不能识别，\\r\\n在很多系统中均适用 os.flush(); //写数据一定要刷新数据 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; JDK7和JDK9中的（）中只能 放置资源对象，否则报错；这里的资源就是实现了Closeable&#x2F;AutoCloseable接口的类对象 字符流的使用字节流读取中文输出会存在问题：会乱码或内存溢出 文件字符输入流：一次读取一份字符12345678910111213141516171819202122import java.io.FileReader;import java.io.Reader;public class FileReaderDemo01 &#123; //目标：每次读取一个字符 public static void main(String[] args) throws Exception &#123; //1. 创建一个字符输入流管道于与源文件接通 Reader fr = new FileReader(&quot;logback-APP\\\\src\\\\data&quot;); //2. 读取一个字符// int code = fr.read();// System.out.println(code);// //3. 使用循环读取字符 int code ; while ((code=fr.read())!=-1)&#123; System.out.print((char)code); &#125; &#125;&#125; 字节流的好处：读取中文字符不会出现乱码（如果代码和文件编码一致）每次读取一个字符会存在的问题：性能较慢 文件字符输入流：一次读取一个字符数组12345678910111213141516171819import java.io.FileReader;import java.io.Reader;public class FileReaderDemo02 &#123; //目标：每次读取一个字符 public static void main(String[] args) throws Exception &#123; //1. 创建一个字符输入流管道于与源文件接通 Reader fr = new FileReader(&quot;logback-APP\\\\src\\\\data&quot;); //2. 用循环每次读取一个字符数组 char [ ] buffer = new char[1024]; int len; while ((len = fr.read(buffer))!=-1)&#123; String rs = new String(buffer,0,len); System.out.print(rs); &#125; &#125;&#125; 每次读取一个字符数组的优势：性能较好 文件字符输出流1234567891011121314151617181920212223242526272829303132import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class FileWriterDemo &#123; public static void main(String[] args) throws Exception &#123; //1. 创建一个字符输出流管道与原文件接通 // Writer fw = new FileWriter(&quot;logback-APP\\\\src\\\\data&quot;);//每次写进去，都会先清空 Writer fw = new FileWriter(&quot;logback-APP\\\\src\\\\data&quot;,true); //a. public void write(int c):写一个字符出去 fw.write(98); fw.write(&#x27;s&#x27;); fw.write(&#x27;徐&#x27;); fw.write(&quot;\\r\\n&quot;); fw.write(&quot;abc 我是个中国人&quot;); fw.write(&quot;\\r\\n&quot;); //c. public void write(char[] buffer):写一个字符数组出去 fw.write(&quot;abc我是中国人&quot;.toCharArray()); fw.write(&quot;\\r\\n&quot;); //d. public void write(String c,int len):写一个字符串的一部分出去 fw.write(&quot;abc我是中国人&quot;,0,4); fw.write(&quot;\\r\\n&quot;); //e. public void write(char[] buffer,int len):写一个1字符数组的一部分出去 fw.write(&quot;abc我是中国人&quot;.toCharArray(),0,4); fw.write(&quot;\\r\\n&quot;); fw.flush(); fw.close(); &#125;&#125; 字节流，字符流总结字节流，字符流如何选择使用：1.字节流适合做一切文本数据的拷贝2.字节流不适合读取中文输出3.字符流适合作、做文本文件的操作（读，写·）","categories":[],"tags":[]},{"title":"Collections 工具类","slug":"Collections 工具类","date":"2022-03-18T01:14:54.026Z","updated":"2022-03-16T17:23:19.463Z","comments":true,"path":"2022/03/18/Collections 工具类/","link":"","permalink":"http://example.com/2022/03/18/Collections%20%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"Collections和Collection的区别 java.util.Collection 是一个集合接口。它是Java集合类的低级接口之一，整个集合框架就围绕一组标准接口而设计。 Collection:单列集合的顶端接口，定义了单列集合的共性内容。Collectons:集合工具类 java.util.Collections是一个包装类。它包含各种有关集合操作的静态多态方法。但是此类不能实例化，工具类服务于java的Collection框架 Collections常用方法1.Shuffle：洗牌方法，当前集合内的数据进行随机排序2.Reverse:逆序排序面对当前集合的元素按照相反的顺序进行排序 3.Sort:对当前集合进行升序排序，实现Comparable接口的类，只能使用一种排序方案这种方案叫做“自然比较”方案。 Collections 自定义排序 待排序对象实现Comparable接口 public interface Comparable此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法。 实现此接口的对象列表（和数组）可以通过 Collections.sort（和 Arrays.sort）进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Collections中的sort方法能对实现了Comparable接口的类进行排序以String类为例，该类实现了Comparable接口，实现了Comparable中的方法compareTo compareToint compareTo(T o)比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 由图中代码所示，排列String类的对象实现根据下标从小到大的字符值，再根据字符串的大小。 如果对一个未实现Comparable接口的类进行排序编译出现错误当Student类实现Comparable接口 由上可知，当所以要想实现对一个集合排序那么这个集合中的对象一定要实现Comparable接口，如果不实现该接口如何对该集合进行排序呢 使用Comparable比较器需要自定义一个比较器对集合进行排序 public interface Comparator强行对某个对象 collection 进行整体排序 的比较函数。可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。 Comparator:比较器,Comparator是一个接口，创建一个Comparator的对象需要实现其抽象方法Compare compareint compare(T o1,T o2)比较用来排序的两个参数。根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。 自定义排序例对杜甫的绝句进行排序（String实现了接口Comparable） 按照最前面阿拉伯数字进行排序当序号不是使用阿拉伯数字标识，将无法进行正确排序，由于String已实现Comparable接口，只是定义的排序规则不适应这次排序，此时需自定义比较器 12345678910111213141516171819202122232425262728import java.util.*;public class ComparableDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; l = new ArrayList&lt;&gt;(); l.add(&quot;贰.一行白鹭上青天&quot;); l.add(&quot;壹.两个黄鹂鸣翠柳&quot;); l.add(&quot;肆.门泊东吴万里船。&quot;); l.add(&quot;叁. 窗含西岭千秋雪&quot;); List&lt;String&gt; sizes = new ArrayList&lt;&gt;(); Collections.addAll(sizes,&quot;壹&quot;,&quot;贰&quot;,&quot;叁&quot;,&quot;肆&quot;); System.out.println(l); Collections.sort(l, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return sizes.indexOf(o1.substring(0, o1.indexOf(&quot;.&quot;))) - sizes.indexOf(o2.substring(0, o2.indexOf(&quot;.&quot;))); //o1.indexOf(&quot;.&quot;)：取“.”的下标 //o1.substring(0,o1.indexOf(&quot;.&quot;)):取从下标0，，至“.”所在下标的前一位 //确定符号标识的大小 &#125; &#125; ); System.out.println(l); &#125;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}